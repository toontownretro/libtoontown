### Definitons ###

#define DEG2RAD 0.01745329238474369
#define RAD2DEG 57.2957763671875
#define PI 3.1415927410125732
#define HALF_PI 1.5707963705062866

### DNAAnimProp (Class) ###

DNAAnimProp::DNAAnimProp(std::string initial_name) : DNAProp(initial_name) {

}

DNAAnimProp::DNAAnimProp(const DNAAnimProp &anim_prop) : DNAProp(anim_prop) {
    anim = anim_prop.anim;
}

std::string DNAAnimProp::get_anim() {
    return anim;
}

void DNAAnimProp::set_anim(std::string &anim) {
    this->anim = anim;
}

NodePath DNAAnimProp::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _np;

    if (code == "DCS") {
        PT(ModelNode) node = new ModelNode(name);
        node->set_preserve_transform(ModelNode::PT_net);
        _np = parent.attach_new_node(node);
    } else {
        NodePath nodepath = store->find_node(code);
        if (nodepath.is_empty()) {
            return NodePath();
        }

        _np = nodepath.copy_to(parent);

        if (nodepath.has_tag("DNARoot")) {
            std::string tag = nodepath.get_tag("DNARoot");
            _np.set_tag("DNARoot", tag);
        }
        if (nodepath.has_tag("DNACode")) {
            std::string tag = nodepath.get_tag("DNACode");
            _np.set_tag("DNACode", tag);
        }
        _np.node()->set_name(name); // Is it this or _np.set_name(name)?
    }
    _np.set_tag("DNAAnim", anim);
    _np.set_pos_hpr_scale(pos, hpr, scale);
    _np.set_color_scale(color);

    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

void DNAAnimProp::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "anim_prop \"" << name << "\" [" << std::endl;
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "anim [ \"" << anim << "\" ]" << std::endl;
    
    // Animated Props always have a position.
    indent(out, indent_level + 1);
    out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    
    // Animated Props always have a hpr.
    indent(out, indent_level + 1);
    if (temp_hpr_fix) {
        out << "nhpr [ ";
    } else {
        out << "hpr [ ";
    }
    out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
        
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNABattleCell (Class) ###

DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos) {
    float14 = 0.0;
    dword10 = 0;
    this->width = width;
    this->height = height;
    this->pos = pos;
}

DNABattleCell::~DNABattleCell() {

}

double DNABattleCell::get_height() {
    return height;
}

LPoint3f DNABattleCell::get_pos() {
    return pos;
}

double DNABattleCell::get_width() {
    return width;
}

void DNABattleCell::set_pos(LPoint3f pos) {
    this->pos = pos;
}

void DNABattleCell::set_width_height(float width, float height) {
    this->width = width;
    this->height = height;
}

void DNABattleCell::output(std::ostream &out) {
    out << "Width: " << width << " Height: " << height << " Pos: " << pos[0] << " " << pos[1] << " " << pos[2];
}

NodePath DNABattleCell::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    return parent;
}

void DNABattleCell::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "battle_cell [ " << width << " " << height << " " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
}

### DNADoor (Class) ###

DNADoor::DNADoor(std::string initial_name) : DNAGroup(initial_name) {
    color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
}

DNADoor::DNADoor(const DNADoor &door) : DNAGroup(door) {
    code = door.code;
    color = door.color;
}

DNADoor::~DNADoor() {

}

std::string DNADoor::get_code() {
    return code;
}

LVecBase4f DNADoor::get_color() {
    return color;
}

void DNADoor::set_code(std::string &code) {
    this->code = code;
}

void DNADoor::set_color(const LVecBase4f &color) {
    this->color = color;
}

void DNADoor::setup_door(NodePath &node, const NodePath &parent, const NodePath &door_origin, DNAStorage *store, std::string &block, const LVecBase4f &color) {
    node.set_pos_hpr_scale(door_origin, LVecBase3f(0.0, 0.0, 0.0), LVecBase3f(0.0, 0.0, 0.0), LVecBase3f(1.0, 1.0, 1.0));
    node.set_color(color);

    NodePath door_hole_left = node.find("door_*_hole_left");
    door_hole_left.set_name("doorFrameHoleLeft");

    NodePath door_hole_right = node.find("door_*_hole_right");
    door_hole_right.set_name("doorFrameHoleRight");

    NodePath door_right = node.find("door_*_right");
    door_right.set_name("rightDoor");

    NodePath door_left = node.find("door_*_left");
    door_left.set_name("leftDoor");

    NodePath door_flat = node.find("door_*_flat");
    if (!door_flat.is_empty()) {
        door_hole_left.wrt_reparent_to(door_flat);
        door_hole_right.wrt_reparent_to(door_flat);

        door_flat.set_effect(DecalEffect::make());

        door_right.wrt_reparent_to(parent);
        door_left.wrt_reparent_to(parent);

        door_right.hide();
        door_left.hide();
    }

    door_hole_left.hide();
    door_hole_right.hide();

    door_right.set_color(color);
    door_left.set_color(color);
    door_hole_left.set_color(LVecBase4f(0.0, 0.0, 0.0, 1.0));
    door_hole_right.set_color(LVecBase4f(0.0, 0.0, 0.0, 1.0));

    NodePath door_trigger = node.find("door_*_trigger");
    door_trigger.wrt_reparent_to(parent);
    door_trigger.set_name("door_trigger_" + block);
}

NodePath DNADoor::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _front_path = parent.find("**/*_front");
    if (!_front_path.get_node(0)->is_geom_node()) {
        _front_path = _front_path.find("**/+GeomNode");
    }

    _front_path.set_effect(DecalEffect::make());
    NodePath node = store->find_node(code);
    if (node.is_empty()) {
        dna_cat.error() << "Door not found: " << code << std::endl;
        return parent;
    }
    node = node.copy_to(_front_path);

    NodePath door_origin = parent.find("**/*door_origin");
    std::string block = store->get_block(parent.get_name());

    setup_door(node, parent, door_origin, store, block, color);
    store->store_block_door_pos_hpr(block, door_origin.get_pos(), door_origin.get_hpr());

    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = node.node();
        store->store_DNAGroup(store_node, PT_this);
    }

    return node;
}

void DNADoor::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "door [" << std::endl;
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNAFlatDoor (Class) ###

DNAFlatDoor::DNAFlatDoor(std::string initial_name) : DNADoor(initial_name) {

}

DNAFlatDoor::DNAFlatDoor(const DNAFlatDoor &door) : DNADoor(door) {
    
}

DNAFlatDoor::~DNAFlatDoor() {

}

NodePath DNAFlatDoor::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath node = store->find_node(code);
    node = node.copy_to(parent);
    
    node.set_scale(LVecBase3f(1.0, 1.0, 1.0));
    node.set_pos_hpr(LVecBase3f(0.5, 0.0, 0.0), LVecBase3f(0.0, 0.0, 0.0));
    
    if (editing) {
        parent.set_effect(DecalEffect::make());
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = node.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return node;
}

void DNAFlatDoor::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "flat_door [" << std::endl;
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNAGroup (Class) ###

DNAGroup::DNAGroup(std::string initial_name) {
    name = initial_name;
}

DNAGroup::DNAGroup(const DNAGroup &group) {
    name = group.name;
    children = group.children;
}

DNAGroup::~DNAGroup() {

}


void DNAGroup::add(PT(DNAGroup) group) {
    children.push_back(group);
}

PT(DNAGroup) DNAGroup::at(size_t index) {
    return children.at(index);
}

void DNAGroup::clear_parent() {
    parent = nullptr;
}

PT(DNAGroup) DNAGroup::current() {
    return children.back();
}

size_t DNAGroup::get_num_children() {
    return children.size();
}

PT(DNAGroup) DNAGroup::get_parent() {
    return parent;
}

void DNAGroup::ls() {
    write(std::cout, 0, 0);
}

void DNAGroup::remove(PT(DNAGroup) group) {
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        if (*it == group) {
            children.erase(it);
            return;
        }
    }
    dna_cat.warning() << "DNAGroup: group not found in map" << std::endl;
}

void DNAGroup::set_parent(PT(DNAGroup) parent) {
    this->parent = parent;
}

NodePath DNAGroup::top_level_traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _np = parent.attach_new_node(name);
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }
    
    if (editing) {
        PT(DNAGroup) PT_this = this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

NodePath DNAGroup::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _np = parent.attach_new_node(name);
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }
    
    if (editing) {
        PT(DNAGroup) PT_this = this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

void DNAGroup::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "group \"" << name << "\" [" << std::endl;
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNAInteractiveProp (Class) ###

DNAInteractiveProp::DNAInteractiveProp(std::string initial_name) : DNAAnimProp(initial_name) {
    cell_id = -1;
}

DNAInteractiveProp::~DNAInteractiveProp() {

}

int DNAInteractiveProp::get_cell_id() {
    return cell_id;
}

void DNAInteractiveProp::set_cell_id(int cell_id) {
    this->cell_id = cell_id;
}

NodePath DNAInteractiveProp::traverse(NodePath &parent, DNAStorage *store, int editing) {
    NodePath _np;

    if (code == "DCS") {
        PT(ModelNode) node = new ModelNode(name);
        node->set_preserve_transform(ModelNode::PT_net);
        _np = parent.attach_new_node(node);
    } else {
        NodePath nodepath = store->find_node(code);
        if (nodepath.is_empty()) {
            return NodePath();
        }

        _np = nodepath.copy_to(parent);

        if (nodepath.has_tag("DNARoot")) {
            std::string tag = nodepath.get_tag("DNARoot");
            _np.set_tag("DNARoot", tag);
        }
        if (nodepath.has_tag("DNACode")) {
            std::string tag = nodepath.get_tag("DNACode");
            _np.set_tag("DNACode", tag);
        }
        _np.node()->set_name(name); // Is it this or _np.set_name(name)?
    }
    _np.set_tag("DNAAnim", anim);
    _np.set_tag("DNACellIndex", std::to_string(cell_id));
    _np.set_pos_hpr_scale(pos, hpr, scale);
    _np.set_color_scale(color);

    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

void DNAInteractiveProp::write(std::ostream &out, DNAStorage *store, int indent_level) {
    indent(out, indent_level);
    out << "interactive_prop \"" << name << "\" [" << std::endl;
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "anim [ \"" << anim << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "cell_id [ " << cell_id << " ]" << std::endl;
    
    // Animated Props always have a position.
    indent(out, indent_level + 1);
    out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    
    // Animated Props always have a hpr.
    indent(out, indent_level + 1);
    if (temp_hpr_fix) {
        out << "nhpr [ ";
    } else {
        out << "hpr [ ";
    }
    out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
        
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNALandmarkBuilding (Class) ###

DNALandmarkBuilding::DNALandmarkBuilding(std::string initial_name) : DNANode(initial_name) {
    wall_color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
}

DNALandmarkBuilding::~DNALandmarkBuilding() {

}

std::string DNALandmarkBuilding::get_article() {
    return article;
}

std::string DNALandmarkBuilding::get_building_type() {
    return building_type;
}

std::string DNALandmarkBuilding::get_code() {
    return code;
}

std::string DNALandmarkBuilding::get_title() {
    return title;
}

LVecBase4f DNALandmarkBuilding::get_wall_color() {
    return wall_color;
}

void DNALandmarkBuilding::set_article(std::string &article) {
    this->article = article;
}

void DNALandmarkBuilding::set_building_type(std::string &type) {
    this->building_type = type;
}

void DNALandmarkBuilding::set_code(std::string &code) {
    this->code = code;
}

void DNALandmarkBuilding::set_title(std::string &title) {
    this->title = title;
}

void DNALandmarkBuilding::set_wall_color(const LVecBase4f &wall_color) {
    this->wall_color = wall_color;
}

void DNALandmarkBuilding::setup_suit_building_origin(NodePath &parent, NodePath &node) {
    if (name.size() > 2 && name[0] == 't' && name[1] == 'b' && isdigit(name[2]) && name.find(':', 0) != std::string::npos) {
        name[0] = 's';
        NodePath found_path = node.find("**/*suit_building_origin");
        if (found_path.is_empty()) {
            dna_cat.warning() << "DNALandmarkBuilding " << name << " did not find **/*suit_building_origin" << std::endl;
            NodePath attached_path = parent.attach_new_node(name);
            attached_path.set_pos_hpr_scale(get_pos(), get_hpr(), get_scale());
            return;
        }
        found_path.wrt_reparent_to(parent);
        found_path.set_name(name);
    }
}

NodePath DNALandmarkBuilding::traverse(NodePath &parent, DNAStorage *store, int editing) {
    NodePath _np = store->find_node(code);
    _np = _np.copy_to(parent);
    _np.set_name(name);
    _np.set_pos_hpr_scale(get_pos(), get_hpr(), get_scale());
    int block_number = store->get_block(name);
    title = store->get_title_from_block_number(block_number);
    article = store->get_article_from_block_number(block_number);
    if (!building_type.size()) {
        setup_suit_building_origin(parent, _np);
    }

    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }

    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    } else {
        _np.flatten_strong();
        if (building_type.compare("hq") != 0) {
            NodePath door_origin = _np.find("**/*door_origin");
            if (!door_origin.is_empty()) {
                door_origin.remove_node();
            }
        }
        NodePath sign_origin = _np.find("**/*sign_origin");
        if (!sign_origin.is_empty()) {
            sign_origin.remove_node();
        }
    }
    return _np;
}

void DNALandmarkBuilding::write(std::ostream &out, DNAStorage *store, int indent_level) {
    indent(out, indent_level);
    out << "landmark_building \"" << name << "\" [" << std::endl;
    indent(out, indent_level + 1);
    out << "code \"" << code << "\" ]" << std::endl;
    if (building_type.size()) {
        indent(out, indent_level + 1);
        out << "building_type \"" << building_type << "\" ]" << std::endl;
    }
    if (article.size()) {
        indent(out, indent_level + 1);
        out << "article \"" << article << "\" ]" << std::endl;
    }
    indent(out, indent_level + 1);
    out << "title \"" << title << "\" ]" << std::endl;

    indent(out, indent_level + 1);
    out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;

    indent(out, indent_level + 1);
    if (temp_hpr_fix) {
        out << "nhpr [ ";
    } else {
        out << "hpr [ ";
    }
    out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;

    if (wall_color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << wall_color[0] << " " << wall_color[1] << " " << wall_color[2] << " " << wall_color[3] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNALoader (Class) ###

DNALoader::DNALoader() {
    data = new DNAData("loader_data");
    root = NodePath("dna");
}

NodePath DNALoader::build_graph(DNAStorage *store, int editing) {
    NodePath traversed_path = data->top_level_traverse(root, store, editing);
    if (traversed_path.is_empty()) {
        dna_cat.debug() << "DNA File contained no geometry, returning empty node" << std::endl;
        return NodePath();
    }
    return traversed_path;
}

PT(DNAData) DNALoader::get_data() {
    return data;
}

### DNANode (Class) ###

DNANode::DNANode(std::string initial_name) : DNAGroup(initial_name) {
    pos = LVecBase3f(0.0, 0.0, 0.0);
    hpr = LVecBase3f(0.0, 0.0, 0.0);
    scale = LVecBase3f(1.0, 1.0, 1.0);
}

DNANode::DNANode(const DNANode &node) : DNAGroup(node) {
    pos = node.pos;
    hpr = node.hpr;
    scale = node.scale;
}

DNANode::~DNANode() {

}

LVecBase3f DNANode::get_hpr() {
    return hpr;
}

LVecBase3f DNANode::get_pos() {
    return pos;
}

LVecBase3f DNANode::get_scale() {
    return scale;
}

void DNANode::set_hpr(const LVecBase3f &hpr) {
    this->hpr = hpr;
}

void DNANode::set_pos(const LVecBase3f &pos) {
    this->pos = pos;
}

void DNANode::set_scale(const LVecBase3f &scale) {
    this->scale = scale;
}

NodePath DNANode::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _np = parent.attach_new_node(name);
    _np.set_pos_hpr_scale(pos, hpr, scale);
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }
    
    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup *)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

void DNANode::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "node \"" << name << "\" [" << std::endl;
    if (pos != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    }
    if (hpr != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        if (temp_hpr_fix) {
            out << "nhpr [ ";
        } else {
            out << "hpr [ ";
        }
        out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
    }
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNAProp (Class) ###

DNAProp::DNAProp(std::string initial_name) : DNANode(initial_name) {
    color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
}

DNAProp::DNAProp(const DNAProp &prop) : DNANode(prop) {
    color = prop.color;
}

DNAProp::~DNAProp() {

}

std::string DNAProp::get_code() {
    return code;
}

LVector4f DNAProp::get_color() {
    return color;
}

void DNAProp::set_code(std::string code) {
    this->code = code;
}

void DNAProp::set_color(const LVecBase4f &color) {
    this->color = color;
}

NodePath DNAProp::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath _np;

    if (code == "DCS") {
        PT(ModelNode) node = new ModelNode(name);
        node->set_preserve_transform(ModelNode::PT_net);
        _np = parent.attach_new_node(node);
    } else {
        NodePath nodepath = store->find_node(code);
        if (nodepath.is_empty()) {
            return NodePath();
        }

        _np = nodepath.copy_to(parent);

        // This is my best guess for as to what it did. 
        // The code is a mess in the decompiler.
        if (nodepath.has_tag("DNARoot")) {
            std::string tag = nodepath.get_tag("DNARoot");
            _np.set_tag("DNARoot", tag);
        }
        if (nodepath.has_tag("DNACode")) {
            std::string tag = nodepath.get_tag("DNACode");
            _np.set_tag("DNACode", tag);
        }
        _np.node()->set_name(name); // Is it this or _np.set_name(name)?
    }
    _np.set_pos_hpr_scale(pos, hpr, scale);
    _np.set_color_scale(color);
    
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }
    
    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return _np;
}

void DNAProp::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "prop \"" << name << "\" [" << std::endl;
    
    // DNAProps always have a code.
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    
    // DNAProps always have a pos.
    indent(out, indent_level + 1);
    out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
        
    // DNAProps always have a hpr.
    indent(out, indent_level + 1);
    if (temp_hpr_fix) {
        out << "nhpr [ ";
    } else {
        out << "hpr [ ";
    }
    out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
        
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNASign (Class) ###

DNASign::DNASign(std::string initial_name) : DNANode(initial_name) {
    color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
}

DNASign::DNASign(const DNASign &Sign) : DNANode(Sign) {
    code = Sign.code;
    color = Sign.color;
}

DNASign::~DNASign() {

}

std::string DNASign::get_code() {
    return code;
}

LVecBase4f DNASign::get_color() {
    return color;
}

void DNASign::set_code(std::string &code) {
    this->code = code;
}

void DNASign::set_color(LVecBase4f &color) {
    this->color = color;
}

NodePath DNASign::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath node = parent.find("**/sign_decal");
    if (node.is_empty()) {
        node = parent.find("**/*_front");
        if (!node.get_node(0)->is_geom_node()) {
            node = node.find("**/+GeomNode");
        }
    }
    node.set_effect(DecalEffect::make());
    if (code.size()) {
        NodePath code_node = store->find_node(code);
        node = code_node->copy_to(node);
        if (node.is_empty()) {
            Notify::out() << "Sign not found in storage: " << code << std::endl;
            return parent;
        }
        node.set_name("sign");
    } else {
        ModelNode sign_node = ModelNode("sign");
        node = node.attach_new_node((PandaNode *)sign_node);
    }
    node.set_depth_write(0, 0);
    node.set_pos_hpr_scale(parent.find("**/*sign_origin"), pos, hpr, scale);
    
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(node, store, editing);
    }
    
    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup *)this;
        PT(PandaNode) store_node = node.node();
        store->store_DNAGroup(store_node, PT_this);
    } else {
        // TODO
    }
}

void DNASign::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "sign [" << std::endl;
    if (code.size()) {
        indent(out, indent_level + 1);
        out << "code [ \"" << code << "\" ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    if (pos != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    }
    if (hpr != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        if (temp_hpr_fix) {
            out << "nhpr [ ";
        } else {
            out << "hpr [ ";
        }
        out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
    }
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNASignBaseline (Class) ###

void DNASignBaseline::DNASignBaseline(std::string initial_name) : DNANode(initial_name) {
    font = NULL;
    pos2 = LVecBase3f(0.0, 0.0, 0.0);
    hpr2 = LVecBase3f(0.0, 0.0, 0.0);
    scale2 = LVecBase3f(1.0, 1.0, 1.0);
    counter = 0;
    indent = 0.0;
    kern = 0.0;
    wiggle = 0.0;
    stumble = 0.0;
    stomp = 0.0;
    floatF4 = 0.0;
    is_space = 1;
    width = 0.0;
    height = 0.0;
    float104 = 0.0;
    angle = 0.0;
}

void DNASignBaseline::baseline_next_pos_hpr_scale(LVector3f &pos, LVector3f &hpr, LVector3f &scale, const LVector3f &size) {
    if (width != 0.0 || height != 0.0) {
        circle_next_pos_hpr_scale(pos, hpr, scale, size);
    } else {
        line_next_pos_hpr_scale(pos, hpr, scale, size);
    }
}

void DNASignBaseline::center(LVector3f &pos, LVector3f &hpr) {
    double current_rotation = 0.0;
    
    if (temp_hpr_fix) {
        current_rotation = -this->hpr[2];
    } else {
        current_rotation = this->hpr[2];
    }
    float rotRad = current_rotation * DEG2RAD;
    if ( 0.0 != width || 0.0 != height ) {
        pos[0] = pos[0] - cos(rotRad + HALF_PI) * (width * 0.5);
        pos[2] = pos[2] - sin(rotRad + HALF_PI) * (height * 0.5);
        if (temp_hpr_fix) {
            hpr[2] = hpr[2] + float104 * 0.5;
        } else {
            hpr[2] = hpr[2] - float104 * 0.5;
        }
    } else {
        --counter;
        double current_stumble = get_current_stumble();
        ++counter;
        double new_stumble = get_current_kern() + current_stumble;
        pos[0] = pos[0] - ((floatF4 + new_stumble) * 0.5) * cos(rotRad);
        pos[2] = pos[2] - ((floatF4 + new_stumble) * 0.5) * sin(rotRad);
    }
}

// TODO: Figure out the not explictly defined references.
void DNASignBaseline::circle_next_pos_hpr_scale(LVector3f &pos, LVector3f &hpr, LVector3f &scale, const LVector3f &size) {
    double v17 = 0.0; 
    LVector4f v38();
    
    scale = scale * this->scale;
    double widthhf = width * 0.5
    double heighthf = height * 0.5;
    double pos_x = pos[0];
    if (width >= 0.0) {
        pos_x = -pos_x;
    }
    double new_pos_x = widthhf * PI;
    new_pos_x = pos_x / new_pos_x * PI;
    new_indent = indent;
    if (width < 0.0) {
        new_indent = -new_indent;
    }
    float v29 = angle * DEG2RAD;
    new_pos_x = DEG2RAD * new_indent + new_pos_x;
    new_pos_x = new_pos_x + v29 + HALF_PI;
    double current_stomp = get_current_stomp();
    stomped_pos_z = pos[2] + current_stomp;
    if (width < 0.0) {
        stomped_pos_z = -stomped_pos_z;
    }
    v39[0] = current_stomp;
    new_pos_x = (stomped_pos_z + widthhf) * cos(new_pos_x);
    new_pos_z = (stomped_pos_z + heighthf) * sin(new_pos_x);
    pos[0] = new_pos_x;
    pos[2] = new_pos_z;
    double current_wiggle = get_current_wiggle();
    if (temp_hpr_fix) {
        v17 = hpr[2] - (angle + new_indent + current_wiggle);
    } else {
        v17 = hpr[2] + (angle + new_indent + current_wiggle);
    }
    hpr[2] = v17;
    float pos_calc = sqrt(new_pos_z * new_pos_z + new_pos_x * new_pos_x);
    if (width < 0.0) {
        float104 = v29 * RAD2DEG;
    }
    v38[1] = scale[0] * size[0];
    double v18 = pos_calc + pos_calc;
    
    // *(double *)((char *)&new_pos_x + 4) = v18; 
    double unknown = v18;
    
    v19 = v38[1] / v18;
    if ( v19 >= 1.0 )
        v19 = 1.0;
    v38[1] = v29;
    float v30 = v29 - (asin(v19) + asin(v19));
    if (width >= 0.0) {
        float104 = RAD2DEG * v30;
    }
    double current_stumble = get_current_stumble;
    v38[1] = angle;
    double calc = kern - current_stumble;
    v21 = asin(calc / unknown);
    calc = v30 - (v21 + v21);
    calc = calc * RAD2DEG;
    angle = calc;
    if (width >= 0.0) {
        if (temp_hpr_fix) {
            hpr[2] = hpr[2] - (calc - v38[1]) * 0.5;
        } else {
            hpr[2] = hpr[2] + (calc - v38[1]) * 0.5;
        }
    }
    ++counter;
}

double DNASignBaseline::get_current_kern() {
    return counter * kern;
}

double DNASignBaseline::get_current_stomp() {
    double current_stomp = stomp;
    if (!(counter & 1)) {
        current_stomp = -current_stomp;
    }
    return current_stomp;
}

double DNASignBaseline::get_current_stumble() {
    double current_stumble = stumble;
    if (!(counter & 1)) {
        current_stumble = -current_stumble;
    }
    return current_stumble;
}

double DNASignBaseline::get_current_wiggle() {
    double current_wiggle = wiggle;
    if (!(counter & 1)) {
        current_wiggle = -current_wiggle;
    }
    return current_wiggle;
}

std::string DNASignBaseline::get_flags() {
    return flags;
}

TextFont *DNASignBaseline::get_font() {
    return font;
}

double DNASignBaseline::get_height() {
    return height;
}

double DNASignBaseline::get_indent() {
    return indent;
}

double DNASignBaseline::get_kern() {
    return kern;
}

double DNASignBaseline::get_stomp() {
    return stomp;
}

double DNASignBaseline::get_stumble() {
    return stumble;
}

double DNASignBaseline::get_width() {
    return width;
}

double DNASignBaseline::get_wiggle() {
    return wiggle;
}

void DNASignBaseline::inc_counter() {
    ++counter;
}

bool DNASignBaseline::isFirstLetterOfWord(std::string letter) {
    if (letter[0] == ' ') {
        is_space = 1;
        return 0;
    }
    bool is_not_space = is_space == 0;
    is_space = 0;
    if (is_not_space) {
        return 0;
    }
    return 1;
}

void DNASignBaseline::line_next_pos_hpr_scale(LVector3f &pos, LVector3f &hpr, LVector3f &scale, const LVector3f &size) {
    scale = scale * this->scale;
    pos = pos + floatBC;
    float current_stumble = get_current_stumble();
    float current_kern = get_current_kern();
    pos[0] = pos[0] + current_kern + current_stumble;
    float current_stomp = get_current_stomp();
    pos[2] = pos[2] + current_stomp;
    floatBC[0] = floatBC[0] + (scale[0] * size[0]);
    floatF4 = (scale[0] * size[0]) + floatF4;
    float current_wiggle = get_current_wiggle();
    if (temp_hpr_fix) {
        hpr[2] = hpr[2] - current_wiggle;
    } else {
        hpr[2] = hpr[2] + current_wiggle;
    }
    // Originally both cases a seperate increment for counter.
    // But since it increments no matter what, I moved it outside 
    // for efficiency. 
    ++counter;
}

void DNASignBaseline::reset() {
    counter = 0;
    is_space = 1;
    floatF4 = 0.0;
    float104 = 0.0;
    angle = 0.0;
}

void DNASignBaseline::reset_counter() {
    counter = 0;
}

void DNASignBaseline::set_flags(std::string flags) {
    this->flags = flags;
}

void DNASignBaseline::set_font(TextFont *font) {
    this->font = font;
}

void DNASignBaseline::set_height(float height) {
    this->height = height;
}

void DNASignBaseline::set_indent(float indent) {
    this->indent = indent;
}

void DNASignBaseline::set_kern(float kern) {
    this->kern = kern;
}

void DNASignBaseline::set_stomp(float stomp) {
    this->stomp = stomp;
}

void DNASignBaseline::set_stumble(float stumble) {
    this->stumble = stumble;
}

void DNASignBaseline::set_width(float width) {
    this->width = width;
}

void DNASignBaseline::set_wiggle(float wiggle) {
    this->wiggle = wiggle;
}

NodePath DNASignBaseline::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    reset();
    NodePath np = parent.attach_new_node("baseline");
    if (code.size()) {
        PT(TextFont) found_font = store->find_font(code);
        if (!found_font) {
            dna_cat.error() << "unable to find baseline font " << code << std::endl;
            return;
        }
        font = found_font;
    }
    np.set_color(color);
    
    if (width < 0.0 || height < 0.0) {
        for (pvector<PT(DNAGroup)>::iterator it = children.end(); it != children.begin(); --it) {
            (*it)->traverse(np, store, editing);
        }
    } else {
        for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
            (*it)->traverse(np, store, editing);
        }
    }
    center(pos, hpr);
    np.set_pos_hpr_scale(pos, hpr, LVecBase3f(1.0, 1.0, 1.0));
    
    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    return np;
}

void DNASignBaseline::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "baseline [" << std::endl;
    if (code.size()) {
        indent(out, indent_level + 1);
        out << "code [ \"" << code << "\" ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    if (pos != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    }
    if (hpr != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        if (temp_hpr_fix) {
            out << "nhpr [ ";
        } else {
            out << "hpr [ ";
        }
        out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
    }
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    if (this->indent != 0.0) {
        indent(out, indent_level + 1);
        out << "indent [ " << this->indent << " ]" << std::endl;
    }
    if (kern != 0.0) {
        indent(out, indent_level + 1);
        out << "kern [ " << kern << " ]" << std::endl;
    }
    if (wiggle != 0.0) {
        indent(out, indent_level + 1);
        out << "wiggle [ " << wiggle << " ]" << std::endl;
    }
    if (stumble != 0.0) {
        indent(out, indent_level + 1);
        out << "stumble [ " << stumble << " ]" << std::endl;
    }
    if (stomp != 0.0) {
        indent(out, indent_level + 1);
        out << "stomp [ " << stomp << " ]" << std::endl;
    }
    if (width != 0.0) {
        indent(out, indent_level + 1);
        out << "width [ " << width << " ]" << std::endl;
    }
    if (height != 0.0) {
        indent(out, indent_level + 1);
        out << "height [ " << height << " ]" << std::endl;
    }
    if (flags.size()) {
        indent(out, indent_level + 1);
        out << "flags [ \"" << flags << "\" ]" << std::endl;
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNASignText (Class) ###

void DNASignText::DNASignText(std::string initial_name) : DNAProp(initial_name) {
    no_color = 1;
}

void DNASignText::set_letters(std::string letters) {
    this->letters = letters;
}

// TODO
NodePath DNASignText::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {

}

void DNASignText::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "text [" << std::endl;
    if (code.size()) {
        indent(out, indent_level + 1);
        out << "code [ \"" << code << "\" ]" << std::endl;
    }
    if (color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << color[0] << " " << color[1] << " " << color[2] << " " << color[3] << " ]" << std::endl;
    }
    if (pos != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    }
    if (hpr != LVecBase3f(0.0, 0.0, 0.0)) {
        indent(out, indent_level + 1);
        if (temp_hpr_fix) {
            out << "nhpr [ ";
        } else {
            out << "hpr [ ";
        }
        out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
    }
    if (scale != LVecBase3f(1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "scale [ " << scale[0] << " " << scale[1] << " " << scale[2] << " ]" << std::endl;
    }
    if (letters == "\"") {
        indent(out, indent_level + 1);
        out << "letters [ '\"' ]" << std::endl;
    } else {
        indent(out, indent_level + 1);
        out << "letters [ \"" << letters << "\" ]" << std::endl;
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNAStreet (Class) ###

DNAStreet::DNAStreet(std::string initial_name) : DNANode(initial_name) {
    curb_color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
    sidewalk_color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
    street_color = LVecBase4f(1.0, 1.0, 1.0, 1.0);
}

DNAStreet::~DNAStreet() {

}

std::string DNAStreet::get_code() {
    return code;
}

LVecBase4f DNAStreet::get_curb_color() {
    return curb_color;
}

std::string DNAStreet::get_curb_texture() {
    return curb_texture;
}

LVecBase4f DNAStreet::get_sidewalk_color() {
    return sidewalk_color;
}

std::string DNAStreet::get_sidewalk_texture() {
    return sidewalk_texture;
}

LVecBase4f DNAStreet::get_street_color() {
    return street_color;
}

std::string DNAStreet::get_street_texture() {
    return street_texture;
}

void DNAStreet::set_code(std::string &code) {
    this->code = code;
}

void DNAStreet::set_curb_color(LVecBase4f &color) {
    this->curb_color = color;
}

void DNAStreet::set_curb_texture(std::string &curb_texture) {
    this->curb_texture = curb_texture;
}

void DNAStreet::set_sidewalk_color(LVecBase4f &color) {
    this->sidewalk_color = color;
}

void DNAStreet::set_sidewalk_texture(std::string &sidewalk_texture) {
    this->sidewalk_texture = sidewalk_texture;
}

void DNAStreet::set_street_color(LVecBase4f &color) {
    this->street_color = color;
}

void DNAStreet::set_street_texture(std::string &street_texture) {
    this->street_texture = street_texture;
}

NodePath DNAStreet::traverse(NodePath &parent, DNAStorage *store, int editing = 0) {
    NodePath node = store->find_node(code);
    node = node.copy_to(parent);
    node.set_name(name);
    
    NodePath street_node = node.find("**/*_street");
    NodePath sidewalk_node = node.find("**/*_sidewalk");
    NodePath curb_node = node.find("**/*_curb");
    if (!street_node.is_empty()) {
        street_node.set_texture(store->find_texture(street_texture), 1);
        street_node.set_color_scale(street_color);
    }
    if (!sidewalk_node.is_empty()) {
        sidewalk_node.set_texture(store->find_texture(sidewalk_texture), 1);
        sidewalk_node.set_color_scale(sidewalk_color);
    }
    if (!curb_node.is_empty()) {
        curb_node.set_texture(store->find_texture(curb_texture), 1);
        curb_node.set_color_scale(curb_color);
    }
    node.set_pos_hpr_scale(pos, hpr, scale);
    
    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup *)this;
        PT(PandaNode) store_node = node.node();
        store->store_DNAGroup(store_node, PT_this);
    }

    return node;
}

void DNAStreet::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "street \"" << name << "\" [" << std::endl;
    indent(out, indent_level + 1);
    out << "code [ \"" << code << "\" ]" << std::endl;
    indent(out, indent_level + 1);
    out << "pos [ " << pos[0] << " " << pos[1] << " " << pos[2] << " ]" << std::endl;
    indent(out, indent_level + 1);
    if (temp_hpr_fix) {
        out << "nhpr [ ";
    } else {
        out << "hpr [ ";
    }
    out << hpr[0] << " " << hpr[1] << " " << hpr[2] << " ]" << std::endl;
    if (street_color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << street_color[0] << " " << street_color[1] << " " << street_color[2] << " " << street_color[3] << " ]" << std::endl;
    }
    if (sidewalk_color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << sidewalk_color[0] << " " << sidewalk_color[1] << " " << sidewalk_color[2] << " " << sidewalk_color[3] << " ]" << std::endl;
    }
    if (curb_color != LVecBase4f(1.0, 1.0, 1.0, 1.0)) {
        indent(out, indent_level + 1);
        out << "color [ " << curb_color[0] << " " << curb_color[1] << " " << curb_color[2] << " " << curb_color[3] << " ]" << std::endl;
    }
    indent(out, indent_level + 1);
    out << "texture [ \"" << street_texture << "\" ]" << std::endl;
    out << "texture [ \"" << sidewalk_texture << "\" ]" << std::endl;
    out << "texture [ \"" << curb_texture << "\" ]" << std::endl;
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### DNASuitEdge (Class) ###

DNASuitEdge::DNASuitEdge(PT(DNASuitPoint) start_point, PT(DNASuitPoint) end_point, std::string zone_id) {
    this->start_point = start_point;
    this->end_point = end_point;
    this->zone_id = zone_id;
}

DNASuitEdge::~DNASuitEdge() {

}

PT(DNASuitPoint) DNASuitEdge::get_end_point() {
    return end_point;
}

PT(DNASuitPoint) DNASuitEdge::get_start_point() {
    return start_point;
}

std::string DNASuitEdge::get_zone_id() {
    return zone_id;
}

bool DNASuitEdge::operator==(const DNASuitEdge &other) {
    return start_point == other.start_point && end_point == other.end_point;
}

void DNASuitEdge::output(std::ostream &out) {
    out << "<" << start_point->index << " " << end_point->index << " zone " << zone_id << ">";
}

void DNASuitEdge::set_zone_id(std::string zone_id) {
    this->zone_id = zone_id;
}

void DNASuitEdge::write(std::ostream &out, DNAStorage *store, int indent_level = 0) {
    indent(out, indent_level);
    out << "suit_edge [ " << start_point->index << " " << end_point->index << " ]" << std::endl;
}

### DNASuitPath (Class) ###

DNASuitPath::DNASuitPath() {

}

DNASuitPath::DNASuitPath(int reserve_length) {
    points.reserve(reserve_length);
}

DNASuitPath::DNASuitPath(const DNASuitPath &path) {
    copy(path);
}

DNASuitPath::~DNASuitPath() {

}

void DNASuitPath::add_point(int point) {
    points.push_back(point);
}

void DNASuitPath::copy(const DNASuitPath &path) {
    points.clear();
    for(pvector<int>::size_type i = 0; i != path.points.size(); i++) {
        points.push_back(path.points[i]);
    }
}

int DNASuitPath::get_num_points() {
    return points.size();
}

int DNASuitPath::get_point_index(int i) {
    return points[i];
}

void DNASuitPath::output(std::ostream &out) {
    out << "Path: [ ";
    for(pvector<int>::size_type i = 0; i != points.size(); i++) {
        out << points[i] << " ";
    }
    out << "]";
}

void DNASuitPath::reverse_path() {
    /*
    // This is the accurate implementation of the psuedocode. 
    // It is unnecessary however.
    pvector<int>::iterator begin = points.begin();
    for(pvector<int>::iterator it = points.end(); begin < it; ++begin; --it) {
        int point = *begin;
        *begin = *it;
        *it = point;
    }
    */
    
    std::reverse(points.begin(), points.end());
}

### DNASuitPoint (Class) ###

enum DNASuitPointType {
    STREET_POINT = 0,
    FRONT_DOOR_POINT = 1,
    SIDE_DOOR_POINT = 2,
    COGHQ_IN_POINT = 3,
    COGHQ_OUT_POINT = 4,
}

DNASuitPoint::DNASuitPoint(int index, DNASuitPointType type, LPoint3f pos, int lb_index = -1) {
    this->index = index;
    this->type = type;
    this->pos = pos;
    this->graph_id = 0;
    this->lb_index = lb_index;
}

DNASuitPoint::~DNASuitPoint() {

}

int DNASuitPoint::get_graph_id() {
    return graph_id;
}

int DNASuitPoint::get_index() {
    return index;
}

int DNASuitPoint::get_landmark_building_index() {
    return lb_index;
}

DNASuitPoint::DNASuitPointType DNASuitPoint::get_point_type() {
    return type;
}

LPoint3f DNASuitPoint::get_pos() {
    return pos;
}

bool DNASuitPoint::is_terminal() {
    return type - 1 <= 1;
}

void DNASuitPoint::output(std::ostream &out) {
    out << "<" << index << ", ";
    switch (type) {
        case DNASuitPointType::STREET_POINT:
          out << "STREET_POINT";
          break;
        case DNASuitPointType::FRONT_DOOR_POINT:
          out << "FRONT_DOOR_POINT";
          break;
        case DNASuitPointType::SIDE_DOOR_POINT:
          out << "SIDE_DOOR_POINT";
          break;
        case DNASuitPointType::COGHQ_IN_POINT:
          out << "COGHQ_IN_POINT";
          break;
        case DNASuitPointType::COGHQ_OUT_POINT:
          out << "COGHQ_OUT_POINT";
          break;
        default:
          out << "**invalid**";
          break;
    }
    out << ", " << pos[0] << " " << pos[1] << " " << pos[2];
    if (lb_index >= 0) {
        out << ", " << lb_index;
    }
    out << ">";
}

void DNASuitPoint::set_graph_id(int graph_id) {
    this->graph_id = graph_id;
}

void DNASuitPoint::set_index(int index) {
    this->index = index;
}

void DNASuitPoint::set_landmark_building_index(int lb_index) {
    this->lb_index = lb_index;
}

void DNASuitPoint::set_point_type(DNASuitPointType type) {
    this->type = type;
}

void DNASuitPoint::set_pos(const LPoint3f &pos) {
    this->pos = pos;
}

void DNASuitPoint::write(std::ostream &out, int indent_level = 0) {
    indent(out, indent_level);
    out << "store_suit_point [ " << index << ", ";
    switch (type) {
        case DNASuitPointType::STREET_POINT:
          out << "STREET_POINT";
          break;
        case DNASuitPointType::FRONT_DOOR_POINT:
          out << "FRONT_DOOR_POINT";
          break;
        case DNASuitPointType::SIDE_DOOR_POINT:
          out << "SIDE_DOOR_POINT";
          break;
        case DNASuitPointType::COGHQ_IN_POINT:
          out << "COGHQ_IN_POINT";
          break;
        case DNASuitPointType::COGHQ_OUT_POINT:
          out << "COGHQ_OUT_POINT";
          break;
        default:
          out << "**invalid**";
          break;
    }
    out << ", " << pos[0] << " " << pos[1] << " " << pos[2];
    if (lb_index >= 0) {
        out << ", " << lb_index;
    }
    out << " ]" << std::endl;
}

### DNAVisGroup (Class) ###

DNAVisGroup::DNAVisGroup(std::string initial_name) : DNAGroup(initial_name) {

}

DNAVisGroup::~DNAVisGroup() {

}

void DNAVisGroup::add_battle_cell(PT(DNABattleCell) cell) {
    battle_cells.push_back(cell);
}

void DNAVisGroup::add_suit_edge(PT(DNASuitEdge) edge) {
    if (edge->get_start_point() == edge->get_end_point()) {
        return;
    }
    suit_edges.push_back(edge);
}

void DNAVisGroup::add_visible(std::string &vis_group_name) {
    visibles.push_back(vis_group_name);
}

PT(DNABattleCell) DNAVisGroup::get_battle_cell(unsigned int i) {
    return battle_cells[i];
}

size_t DNAVisGroup::get_num_battle_cells() {
    return battle_cells.size();
}

size_t DNAVisGroup::get_num_suit_edges() {
    return suit_edges.size();
}

size_t DNAVisGroup::get_num_visibles() {
    return visibles.size();
}

PT(DNASuitEdge) DNAVisGroup::get_suit_edge(unsigned int i) {
    return suit_edges[i];
}

std::string DNAVisGroup::get_visible_name(unsigned int i) {
    return visibles[i];
}

void DNAVisGroup::remove_battle_cell(PT(DNABattleCell) cell) {
    for (pvector<PT(DNABattleCell)>::iterator it = battle_cells.begin(); it != battle_cells.end(); ++it) {
        if (*it == cell) {
            battle_cells.erase(it);
            return;
        }
    }
    dna_cat.warning() << "DNABattleCell: cell not found in vector: ";
    cell->output(dna_cat.warning());
    dna_cat.warning() << std::endl;
}

void DNAVisGroup::remove_suit_edge(PT(DNASuitEdge) edge) {
    for (pvector<PT(DNASuitEdge)>::iterator it = suit_edges.begin(); it != suit_edges.end(); ++it) {
        if (*it == edge) {
            suit_edges.erase(it);
            return;
        }
    }
    // In libtoontown, .debug() and .spam() return a null Notify stream for both dna_cat and pets_cat.
    // This means that this notify out has to be either of those options.
    dna_cat.debug() << "DNASuitEdge: edge not found in vector: ";
    edge->output(dna_cat.debug());
    dna_cat.debug() << std::endl;
}

void DNAVisGroup::remove_visible(std::string &vis_group_name) {
    for (pvector<std::string>::iterator it = visibles.begin(); it != visibles.end(); ++it) {
        if (it->compare(vis_group_name) == 0) {
            visibles.erase(it);
            return;
        }
    }
    dna_cat.warning() << "DNAVisGroup: vis group not found in vector: " << vis_group_name << std::endl;
}

NodePath DNAVisGroup::traverse(NodePath &parent, DNAStorage *store, int editing) {
    NodePath _np = parent.attach_new_node(name);
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->traverse(_np, store, editing);
    }

    if (editing) {
        PT(DNAGroup) PT_this = (DNAGroup*)this;
        PT(PandaNode) store_node = _np.node();
        store->store_DNAGroup(store_node, PT_this);
    }
    store->store_DNAVisGroup(_np.node(), this);
    return _np;
}

void DNAVisGroup::write(std::ostream &out, DNAStorage *store, int indent_level) {
    indent(out, indent_level);
    out << "visgroup " << name << " [" << std::endl;
    indent(out, indent_level + 1);
    out << "vis [ \"";
    for (pvector<std::string>::iterator it = visibles.begin(); it != visibles.end(); ++it) {
        out << *it << "\" ";
    }
    out << "]" << std::endl;
    for (pvector<PT(DNASuitEdge)>::iterator it = suit_edges.begin(); it != suit_edges.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    for (pvector<PT(DNABattleCell)>::iterator it = battle_cells.begin(); it != battle_cells.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    for (pvector<PT(DNAGroup)>::iterator it = children.begin(); it != children.end(); ++it) {
        (*it)->write(out, store, indent_level + 1);
    }
    indent(out, indent_level);
    out << "]" << std::endl;
}

### SuitLeg (Class) ###

enum Type {
    WalkFromStreet = 0x0,
    WalkToStreet = 0x1,
    Walk = 0x2,
    FromSky = 0x3,
    ToSky = 0x4,
    FromSuitBuilding = 0x5,
    ToSuitBuilding = 0x6,
    ToToonBuilding = 0x7,
    FromCogHQ = 0x8,
    ToCogHQ = 0x9,
    Off = 0xA,
};

SuitLeg::SuitLeg(SuitLeg::Type type, double start_time, double leg_time, int zone_id, int block_number, const DNASuitPoint *point_a, const DNASuitPoint *point_b) {
    this->start_time = start_time;
    this->zone_id = zone_id;
    this->leg_time = leg_time;
    this->type = type;
    this->block_number = block_number;
    this->point_a = point_a->index;
    this->point_b = point_b->index;
    pos_a = point_a->get_pos();
    pos_b = point_b->get_pos();
}

SuitLeg::~SuitLeg() {

}

void SuitLeg::operator=(SuitLeg &other) {
    type = other.type;
    start_time = other.start_time;
    leg_time = other.leg_time;
    zone_id = other.zone_id;
    block_number = other.block_number;
    point_a = other.point_a;
    point_b = other.point_b;
    pos_a = other.pos_a;
    pos_b = other.pos_b;
}

int SuitLeg::get_block_number() {
    return block_number;
}

double SuitLeg::get_leg_time() {
    return leg_time;
}

int SuitLeg::get_point_a() {
    return point_a;
}

int SuitLeg::get_point_b() {
    return point_b;
}

LPoint3f SuitLeg::get_pos_a() {
    return pos_a;
}

LPoint3f SuitLeg::get_pos_at_time(double time) {
    LPoint3f point;
    
    switch (type) {
        case Type::FromSky:
        case Type::FromSuitBuilding:
        case Type::FromCogHQ:
            point = pos_a;
            break;
        case Type::ToSky:
        case Type::ToSuitBuilding:
        case Type::ToToonBuilding:
        case Type::ToCogHQ:
        case Type::Off:
            point = pos_b;
            break;
        default:
            if (time >= 0.0) {
                if (time > leg_time) {
                    point = pos_b;
                } else {
                    double new_time = time / leg_time;
                    point = (pos_b - pos_a) * new_time;
                    point = pos_a + point;
                }
            } else {
                point = pos_a;
            }
            break;
    }
    return point;
}

LPoint3f SuitLeg::get_pos_b() {
    return pos_b;
}

double SuitLeg::get_start_time() {
    return start_time;
}

std::string SuitLeg::get_type_name(SuitLeg::Type type) {
    switch (type) {
        case Type::WalkFromStreet:
            return "WalkFromStreet";
        case Type::WalkToStreet:
            return "WalkToStreet";
        case Type::Walk:
            return "Walk";
        case Type::FromSky:
            return "FromSky";
        case Type::ToSky:
            return "ToSky";
        case Type::FromSuitBuilding:
            return "FromSuitBuilding";
        case Type::ToSuitBuilding:
            return "ToSuitBuilding";
        case Type::ToToonBuilding:
            return "ToToonBuilding";
        case Type::FromCogHQ:
            return "FromCogHQ";
        case Type::ToCogHQ:
            return "ToCogHQ";
        case Type::Off:
            return "Off";
        default:
            return "**invalid**";
    }
}

int SuitLeg::get_zone_id() {
    return zone_id;
}

void SuitLeg::output(std::ostream &out) {
    out << "(" << get_type_name(type) << ", " << start_time << " (" << leg_time << "), " << zone_id << ", " << point_a << ", " << point_b << ")";
}


### SuitLegList (Class) ###

SuitLegList::SuitLegList(SuitLegList *this, const DNASuitPath *path, const DNAStorage &storage, double suit_walk_speed, double from_sky_time, double to_sky_time, double, from_suit_building_time, double to_suit_building_time, double to_toon_building_time) {
    double suit_time = 0.0;
    SuitLeg::Type type = SuitLeg::Type::FromSky;
    
    DNASuitPoint *point_a = store->get_suit_point_with_index(path->points[0]);
    DNASuitPoint *point_b = store->get_suit_point_with_index(path->points[1]);
    if (point_a->type == SuitLeg::Type::Walk) {
        type = SuitLeg::Type::FromSuitBuilding;
    }
    if (type == SuitLeg::Type::FromSky) {
        suit_time = from_sky_time;
    } else if (type == SuitLeg::Type::FromSuitBuilding) {
        suit_time = from_suit_building_time;
    }
}